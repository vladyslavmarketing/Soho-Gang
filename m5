//+------------------------------------------------------------------+  
//|                XAUUSD GOLD TRAND FUCKER                    |  
//|                         Версия 3.0                               |  
//+------------------------------------------------------------------+  
#property copyright "GOLD TRAND FUCKER"  
#property link      "https://www.GOLDTRANDFUCKER.com"  
#property version   "1.0"  

#include <Trade\Trade.mqh>  
#include <Trade\PositionInfo.mqh>  

// Общие параметры  
input double InitialLot = 0.01;          // Начальный размер лота  
input int Magic = 123456;                // Магический номер для идентификации ордеров  
input bool UseAutoLotSize = true;        // Использовать автоматический расчет лота  
input double RiskPercent = 1.0;          // Процент риска от баланса (если UseAutoLotSize=true)  
input bool UseTrailingStop = true;       // Использовать трейлинг-стоп  
input int TrailingStart = 100;           // Активация трейлинга (в пунктах прибыли)  
input int TrailingStep = 50;             // Шаг трейлинга (в пунктах)  

// Параметры стратегии  
input bool UseVolatilityEntry = true;    // Использовать вход по волатильности  
input int ATR_Period = 14;               // Период ATR для измерения волатильности  
input double ATR_Multiplier = 2.0;       // Множитель ATR для стоп-лосса  
input double TP_Multiplier = 2.0;        // Множитель для тейк-профита (от стоп-лосса)  

// Параметры уровней поддержки/сопротивления  
input bool UseSupportResistance = true;  // Использовать уровни поддержки/сопротивления  
input int SR_Period = 20;                // Период для определения уровней  
input double SR_Deviation = 0.05;        // Отклонение для определения уровней (%)  

// Параметры фильтра тренда  
input bool UseTrendFilter = true;        // Использовать фильтр тренда  
input int MA_Fast_Period = 8;            // Период быстрой MA  
input int MA_Slow_Period = 21;           // Период медленной MA  
input ENUM_MA_METHOD MA_Method = MODE_EMA; // Метод усреднения  

// Таймфреймы для анализа  
input ENUM_TIMEFRAMES MainTimeframe = PERIOD_H1; // Основной таймфрейм для торговли  
input ENUM_TIMEFRAMES TrendTimeframe = PERIOD_H4; // Таймфрейм для определения тренда  

// Параметры для торговли в зависимости от сессии  
input bool UseSessionFilter = true;      // Фильтровать по торговым сессиям  
input bool TradeLondonSession = true;    // Торговать в лондонскую сессию  
input bool TradeNewYorkSession = true;   // Торговать в нью-йоркскую сессию  
input bool TradeAsianSession = true;    // Торговать в азиатскую сессию  

// Глобальные переменные  
CTrade trade;                            // Объект для торговых операций  
CPositionInfo positionInfo;              // Информация о позициях  
int atrHandle, maSlow, maFast;           // Хендлы индикаторов  
double point;                            // Размер пункта  
int symbolDigits;                        // Количество знаков после запятой  
double highestHigh, lowestLow;           // Экстремумы для уровней поддержки/сопротивления  
int fileHandle;                          // Файл для логирования  
datetime lastOrderTime;                  // Время последнего ордера  
int consecutiveLosses = 0;               // Счетчик последовательных убытков  
bool marketTrending = false;             // Флаг тренда на рынке  

//+------------------------------------------------------------------+  
//| Expert initialization function                                    |  
//+------------------------------------------------------------------+  
int OnInit()  
{  
   // Базовая настройка  
   trade.SetExpertMagicNumber(Magic);  
   trade.SetDeviationInPoints(10);   // Допустимое проскальзывание  
   trade.SetTypeFilling(ORDER_FILLING_FOK); // Способ исполнения ордера  
   
   // Получаем значение пункта и знаков после запятой  
   symbolDigits = (int)SymbolInfoInteger(Symbol(), SYMBOL_DIGITS);  
   point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);  
   
   // Для золота корректируем размер пункта  
   if(StringFind(Symbol(), "GOLD") >= 0 || StringFind(Symbol(), "XAU") >= 0)  
   {  
      if(symbolDigits == 2) point = 0.01;  // Для золота с 2 знаками  
      if(symbolDigits == 3) point = 0.001; // Для золота с 3 знаками  
   }  
   
   // Создаем лог-файл  
   string fileName = "GoldTrader_Log_" + TimeToString(TimeCurrent(), TIME_DATE) + ".txt";  
   fileHandle = FileOpen(fileName, FILE_WRITE|FILE_TXT);  
   
   if(fileHandle == INVALID_HANDLE)  
   {  
      Print("Ошибка создания лог-файла: ", GetLastError());  
   }  
   
   // Инициализация индикаторов  
   atrHandle = iATR(Symbol(), MainTimeframe, ATR_Period);  
   maFast = iMA(Symbol(), TrendTimeframe, MA_Fast_Period, 0, MA_Method, PRICE_CLOSE);  
   maSlow = iMA(Symbol(), TrendTimeframe, MA_Slow_Period, 0, MA_Method, PRICE_CLOSE);  
   
   if(atrHandle == INVALID_HANDLE || maFast == INVALID_HANDLE || maSlow == INVALID_HANDLE)  
   {  
      Log("Ошибка инициализации индикаторов: " + IntegerToString(GetLastError()));  
      return INIT_FAILED;  
   }  
   
   lastOrderTime = 0;  
   
   Log("Бот инициализирован для " + Symbol() + ". Размер пункта: " + DoubleToString(point, 5) +   
       ", знаков: " + IntegerToString(symbolDigits));  
   
   return(INIT_SUCCEEDED);  
}  

//+------------------------------------------------------------------+  
//| Expert deinitialization function                                  |  
//+------------------------------------------------------------------+  
void OnDeinit(const int reason)  
{  
   // Освобождаем индикаторы  
   if(atrHandle != INVALID_HANDLE) IndicatorRelease(atrHandle);  
   if(maFast != INVALID_HANDLE) IndicatorRelease(maFast);  
   if(maSlow != INVALID_HANDLE) IndicatorRelease(maSlow);  
   
   // Закрываем лог-файл  
   if(fileHandle != INVALID_HANDLE) FileClose(fileHandle);  
   
   Log("Бот остановлен. Причина: " + IntegerToString(reason));  
}  

//+------------------------------------------------------------------+  
//| Expert tick function                                              |  
//+------------------------------------------------------------------+  
void OnTick()  
{  
   // Проверка нового бара  
   static datetime lastBarTime = 0;  
   datetime currentBarTime = iTime(Symbol(), MainTimeframe, 0);  
   
   // Управление открытыми позициями (трейлинг-стоп)  
   if(UseTrailingStop) ManageOpenPositions();  
   
   // Анализируем только на новом баре  
   if(currentBarTime == lastBarTime) return;  
   
   lastBarTime = currentBarTime;  
   Log("Анализ нового бара: " + TimeToString(currentBarTime));  
   
   // Проверка фильтра сессий  
   if(UseSessionFilter && !IsActiveSession())  
   {  
      Log("Торговля в текущую сессию отключена. Пропускаем анализ.");  
      return;  
   }  
   
   // Проверка наличия открытых позиций  
   int positionsTotal = PositionsTotal();  
   for(int i = 0; i < positionsTotal; i++)  
   {  
      if(positionInfo.SelectByIndex(i))  
      {  
         if(positionInfo.Symbol() == Symbol() && positionInfo.Magic() == Magic)  
         {  
            Log("Уже есть открытая позиция. Пропускаем анализ.");  
            return;  
         }  
      }  
   }  
   
   // Обновление информации о тренде  
   UpdateMarketCondition();  
   
   // Обновление уровней поддержки/сопротивления  
   if(UseSupportResistance) UpdateSupportResistanceLevels();  
   
   // Получение данных ATR для определения волатильности  
   double atr = GetATRValue();  
   if(atr <= 0)  
   {  
      Log("Не удалось получить значение ATR. Пропускаем анализ.");  
      return;  
   }  
   
   // Получение текущих цен  
   double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);  
   
   // Определение возможности входа в рынок  
   bool canEnterLong = false;  
   bool canEnterShort = false;  
   
   // Проверка условий входа по тренду  
   if(UseTrendFilter)  
   {  
      double maFastValue = GetMAValue(maFast);  
      double maSlowValue = GetMAValue(maSlow);  
      
      if(maFastValue > maSlowValue)  
      {  
         canEnterLong = true;  
         Log("Тренд восходящий: Fast MA (" + DoubleToString(maFastValue, symbolDigits) +   
             ") > Slow MA (" + DoubleToString(maSlowValue, symbolDigits) + ")");  
      }  
      else if(maFastValue < maSlowValue)  
      {  
         canEnterShort = true;  
         Log("Тренд нисходящий: Fast MA (" + DoubleToString(maFastValue, symbolDigits) +   
             ") < Slow MA (" + DoubleToString(maSlowValue, symbolDigits) + ")");  
      }  
      else  
      {  
         Log("Нет четкого тренда. Fast MA = Slow MA.");  
         return;  
      }  
   }  
   else  
   {  
      // Если фильтр тренда отключен, разрешаем оба направления  
      canEnterLong = true;  
      canEnterShort = true;  
   }  
   
   // Проверка уровней поддержки/сопротивления  
   if(UseSupportResistance)  
   {  
      double distanceToResistance = MathAbs(highestHigh - currentPrice) / currentPrice * 100;  
      double distanceToSupport = MathAbs(currentPrice - lowestLow) / currentPrice * 100;  
      
      Log("Расстояние до сопротивления: " + DoubleToString(distanceToResistance, 2) +   
          "%, до поддержки: " + DoubleToString(distanceToSupport, 2) + "%");  
      
      // Не входим в покупку близко к сопротивлению  
      if(distanceToResistance < SR_Deviation)  
      {  
         canEnterLong = false;  
         Log("Слишком близко к сопротивлению для покупки.");  
      }  
      
      // Не входим в продажу близко к поддержке  
      if(distanceToSupport < SR_Deviation)  
      {  
         canEnterShort = false;  
         Log("Слишком близко к поддержке для продажи.");  
      }  
   }  
   
   // Дополнительная проверка на скачки волатильности  
   double normalATR = GetAverageATR(10);  
   if(atr > normalATR * 2)  
   {  
      Log("Аномальная волатильность! ATR = " + DoubleToString(atr, symbolDigits) +   
          ", средняя = " + DoubleToString(normalATR, symbolDigits) + ". Пропускаем торговлю.");  
      return;  
   }  
   
   // Проверка времени с последней сделки (минимум 15 минут)  
   if(TimeCurrent() - lastOrderTime < 360)  
   {  
      Log("С последней сделки прошло менее 15 минут. Пропускаем анализ.");  
      return;  
   }  
   
   // Расчет размера лота  
   double lotSize = InitialLot;  
   if(UseAutoLotSize)  
   {  
      lotSize = CalculateLotSize(atr * ATR_Multiplier);  
      Log("Расчетный размер лота: " + DoubleToString(lotSize, 2) + " (риск " + DoubleToString(RiskPercent, 1) + "%)");  
   }  
   
   // Проверка последовательных убытков для уменьшения риска  
   if(consecutiveLosses >= 3)  
   {  
      lotSize = lotSize / 2; // Уменьшаем размер позиции после серии убытков  
      Log("Уменьшен размер лота после " + IntegerToString(consecutiveLosses) + " последовательных убытков: " + DoubleToString(lotSize, 2));  
   }  
   
   // Принятие решения о входе в рынок  
   if(canEnterLong && IsVolatilityFavorable(true, atr))  
   {  
      // Открываем позицию на покупку с отложенным ордером  
      double entryPrice = SymbolInfoDouble(Symbol(), SYMBOL_ASK);  
      double stopLoss = NormalizeDouble(entryPrice - (atr * ATR_Multiplier), symbolDigits);  
      double takeProfit = NormalizeDouble(entryPrice + (atr * ATR_Multiplier * TP_Multiplier), symbolDigits);  
      
      Log("Условия для ПОКУПКИ выполнены! Вход: " + DoubleToString(entryPrice, symbolDigits) +   
          ", SL: " + DoubleToString(stopLoss, symbolDigits) +   
          ", TP: " + DoubleToString(takeProfit, symbolDigits));  
      
      if(OpenBuyPosition(lotSize, stopLoss, takeProfit))  
      {  
         lastOrderTime = TimeCurrent();  
      }  
   }  
   else if(canEnterShort && IsVolatilityFavorable(false, atr))  
   {  
      // Открываем позицию на продажу с отложенным ордером  
      double entryPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);  
      double stopLoss = NormalizeDouble(entryPrice + (atr * ATR_Multiplier), symbolDigits);  
      double takeProfit = NormalizeDouble(entryPrice - (atr * ATR_Multiplier * TP_Multiplier), symbolDigits);  
      
      Log("Условия для ПРОДАЖИ выполнены! Вход: " + DoubleToString(entryPrice, symbolDigits) +   
          ", SL: " + DoubleToString(stopLoss, symbolDigits) +   
          ", TP: " + DoubleToString(takeProfit, symbolDigits));  
      
      if(OpenSellPosition(lotSize, stopLoss, takeProfit))  
      {  
         lastOrderTime = TimeCurrent();  
      }  
   }  
   else  
   {  
      Log("Условия для входа в рынок не выполнены.");  
   }  
}  

//+------------------------------------------------------------------+  
//| Проверка активной сессии                                         |  
//+------------------------------------------------------------------+  
bool IsActiveSession()  
{  
   MqlDateTime dt;  
   TimeToStruct(TimeCurrent(), dt);  
   
   int currentHour = dt.hour; // GMT time  
   
   // Asian session: 00:00-08:00 GMT  
   bool isAsianSession = (currentHour >= 0 && currentHour < 8);  
   
   // London session: 08:00-16:00 GMT  
   bool isLondonSession = (currentHour >= 8 && currentHour < 16);  
   
   // New York session: 13:00-21:00 GMT  
   bool isNewYorkSession = (currentHour >= 13 && currentHour < 21);  
   
   return (isAsianSession && TradeAsianSession) ||   
          (isLondonSession && TradeLondonSession) ||   
          (isNewYorkSession && TradeNewYorkSession);  
}  

//+------------------------------------------------------------------+  
//| Обновление рыночных условий                                      |  
//+------------------------------------------------------------------+  
void UpdateMarketCondition()  
{  
   double maFastValues[];  
   double maSlowValues[];  
   ArrayResize(maFastValues, 3);  
   ArrayResize(maSlowValues, 3);  
   ArraySetAsSeries(maFastValues, true);  
   ArraySetAsSeries(maSlowValues, true);  
   
   if(CopyBuffer(maFast, 0, 0, 3, maFastValues) <= 0 ||   
      CopyBuffer(maSlow, 0, 0, 3, maSlowValues) <= 0)  
   {  
      Log("Ошибка копирования данных MA: " + IntegerToString(GetLastError()));  
      return;  
   }  
   
   // Если быстрая MA пересекает медленную снизу вверх - восходящий тренд  
   bool trendUp = maFastValues[0] > maSlowValues[0] && maFastValues[1] < maSlowValues[1];  
   
   // Если быстрая MA пересекает медленную сверху вниз - нисходящий тренд  
   bool trendDown = maFastValues[0] < maSlowValues[0] && maFastValues[1] > maSlowValues[1];  
   
   // Проверка силы тренда  
   if(trendUp || trendDown)  
   {  
      marketTrending = true;  
      Log("Обнаружен " + (trendUp ? "восходящий" : "нисходящий") + " тренд");  
   }  
   else  
   {  
      // Проверяем, что быстрая MA находится строго выше или строго ниже медленной  
      bool strongUptrend = maFastValues[0] > maSlowValues[0] && maFastValues[1] > maSlowValues[1] && maFastValues[2] > maSlowValues[2];  
      bool strongDowntrend = maFastValues[0] < maSlowValues[0] && maFastValues[1] < maSlowValues[1] && maFastValues[2] < maSlowValues[2];  
      
      marketTrending = strongUptrend || strongDowntrend;  
      if(marketTrending)  
      {  
         Log("Продолжение сильного " + (strongUptrend ? "восходящего" : "нисходящего") + " тренда");  
      }  
      else  
      {  
         Log("Рынок не в тренде, возможен боковик");  
      }  
   }  
}  

//+------------------------------------------------------------------+  
//| Обновление уровней поддержки и сопротивления                     |  
//+------------------------------------------------------------------+  
void UpdateSupportResistanceLevels()  
{  
   double high[];  
   double low[];  
   ArrayResize(high, SR_Period);  
   ArrayResize(low, SR_Period);  
   ArraySetAsSeries(high, true);  
   ArraySetAsSeries(low, true);  
   
   if(CopyHigh(Symbol(), MainTimeframe, 0, SR_Period, high) <= 0 ||   
      CopyLow(Symbol(), MainTimeframe, 0, SR_Period, low) <= 0)  
   {  
      Log("Ошибка копирования ценовых данных: " + IntegerToString(GetLastError()));  
      return;  
   }  
   
   // Находим максимум и минимум за период  
   highestHigh = high[ArrayMaximum(high, 0, SR_Period)];  
   lowestLow = low[ArrayMinimum(low, 0, SR_Period)];  
   
   Log("Уровень сопротивления: " + DoubleToString(highestHigh, symbolDigits) +   
       ", уровень поддержки: " + DoubleToString(lowestLow, symbolDigits));  
}  

//+------------------------------------------------------------------+  
//| Получение значения ATR                                           |  
//+------------------------------------------------------------------+  
double GetATRValue()  
{  
   double atrBuffer[];  
   ArrayResize(atrBuffer, 1);  
   ArraySetAsSeries(atrBuffer, true);  
   
   if(CopyBuffer(atrHandle, 0, 0, 1, atrBuffer) <= 0)  
   {  
      Log("Ошибка копирования данных ATR: " + IntegerToString(GetLastError()));  
      return 0;  
   }  
   
   return atrBuffer[0];  
}  

//+------------------------------------------------------------------+  
//| Получение среднего значения ATR за указанный период              |  
//+------------------------------------------------------------------+  
double GetAverageATR(int period)  
{  
   double atrBuffer[];  
   ArrayResize(atrBuffer, period);  
   ArraySetAsSeries(atrBuffer, true);  
   
   if(CopyBuffer(atrHandle, 0, 0, period, atrBuffer) <= 0)  
   {  
      Log("Ошибка копирования данных ATR: " + IntegerToString(GetLastError()));  
      return 0;  
   }  
   
   double sum = 0;  
   for(int i = 0; i < period; i++)  
   {  
      sum += atrBuffer[i];  
   }  
   
   return sum / period;  
}  

//+------------------------------------------------------------------+  
//| Получение значения MA                                            |  
//+------------------------------------------------------------------+  
double GetMAValue(int handle)  
{  
   double maBuffer[];  
   ArrayResize(maBuffer, 1);  
   ArraySetAsSeries(maBuffer, true);  
   
   if(CopyBuffer(handle, 0, 0, 1, maBuffer) <= 0)  
   {  
      Log("Ошибка копирования данных MA: " + IntegerToString(GetLastError()));  
      return 0;  
   }  
   
   return maBuffer[0];  
}  

//+------------------------------------------------------------------+  
//| Проверка благоприятных условий волатильности                     |  
//+------------------------------------------------------------------+  
bool IsVolatilityFavorable(bool isLong, double atr)  
{  
   if(!UseVolatilityEntry) return true; // Если отключено - всегда благоприятно  
   
   // В трендовом рынке требуем нормальную волатильность  
   if(marketTrending)  
   {  
      double averageATR = GetAverageATR(ATR_Period * 2);  
      return atr >= averageATR * 0.8 && atr <= averageATR * 1.5;  
   }  
   
   // В боковике требуем повышенную волатильность для пробоя  
   double averageATR = GetAverageATR(ATR_Period);  
   return atr > averageATR * 1.2;  
}  

//+------------------------------------------------------------------+  
//| Расчет размера лота на основе риска                              |  
//+------------------------------------------------------------------+  
double CalculateLotSize(double stopLossPoints)  
{  
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);  
   double riskAmount = balance * RiskPercent / 100;  
   
   double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);  
   double tickSize = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_SIZE);  
   
   // Для золота корректируем  
   if(Symbol() == "XAUUSD" || Symbol() == "GOLD")  
   {  
      // Корректировка для золота - умножаем на 10 для USD/oz  
      tickValue *= 10;  
   }  
   
   double pricePerLot = (stopLossPoints / tickSize) * tickValue;  
   double lotSize = riskAmount / pricePerLot;  
   
   // Округление и ограничение по минимальному/максимальному размеру лота  
   double minLot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);  
   double maxLot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX);  
   double lotStep = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_STEP);  
   
   lotSize = MathFloor(lotSize / lotStep) * lotStep;  
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));  
   
   return lotSize;  
}  

//+------------------------------------------------------------------+  
//| Открытие позиции на покупку                                      |  
//+------------------------------------------------------------------+  
bool OpenBuyPosition(double lotSize, double stopLoss, double takeProfit)  
{  
   // Проверяем минимальную дистанцию стопов  
   double minStopLevel = SymbolInfoInteger(Symbol(), SYMBOL_TRADE_STOPS_LEVEL) * point;  
   double askPrice = SymbolInfoDouble(Symbol(), SYMBOL_ASK);  
   
   if(askPrice - stopLoss < minStopLevel)  
   {  
      Log("Стоп-лосс слишком близко к текущей цене. Минимальное расстояние: " +   
          DoubleToString(minStopLevel, symbolDigits));  
      stopLoss = NormalizeDouble(askPrice - minStopLevel, symbolDigits);  
   }  
   
   if(takeProfit - askPrice < minStopLevel)  
   {  
      Log("Тейк-профит слишком близко к текущей цене. Минимальное расстояние: " +   
          DoubleToString(minStopLevel, symbolDigits));  
      takeProfit = NormalizeDouble(askPrice + minStopLevel, symbolDigits);  
   }  
   
   // Открываем рыночный ордер на покупку  
   Log("Открываем BUY по рынку: Lot=" + DoubleToString(lotSize, 2) +   
       ", SL=" + DoubleToString(stopLoss, symbolDigits) +   
       ", TP=" + DoubleToString(takeProfit, symbolDigits));  
   
   if(!trade.Buy(lotSize, Symbol(), 0, stopLoss, takeProfit, "Gold Volatility Buy"))  
   {  
      Log("ОШИБКА открытия BUY: " + IntegerToString(trade.ResultRetcode()) +   
          ", " + trade.ResultComment());  
      return false;  
   }  
   
   Log("Успешно открыт ордер BUY #" + IntegerToString(trade.ResultOrder()) +   
       " по цене " + DoubleToString(trade.ResultPrice(), symbolDigits));  
   return true;  
}  

//+------------------------------------------------------------------+  
//| Открытие позиции на продажу                                      |  
//+------------------------------------------------------------------+  
bool OpenSellPosition(double lotSize, double stopLoss, double takeProfit)  
{  
   // Проверяем минимальную дистанцию стопов  
   double minStopLevel = SymbolInfoInteger(Symbol(), SYMBOL_TRADE_STOPS_LEVEL) * point;  
   double bidPrice = SymbolInfoDouble(Symbol(), SYMBOL_BID);  
   
   if(stopLoss - bidPrice < minStopLevel)  
   {  
      Log("Стоп-лосс слишком близко к текущей цене. Минимальное расстояние: " +   
          DoubleToString(minStopLevel, symbolDigits));  
      stopLoss = NormalizeDouble(bidPrice + minStopLevel, symbolDigits);  
   }  
   
   if(bidPrice - takeProfit < minStopLevel)  
   {  
      Log("Тейк-профит слишком близко к текущей цене. Минимальное расстояние: " +   
          DoubleToString(minStopLevel, symbolDigits));  
      takeProfit = NormalizeDouble(bidPrice - minStopLevel, symbolDigits);  
   }  
   
   // Открываем рыночный ордер на продажу  
   Log("Открываем SELL по рынку: Lot=" + DoubleToString(lotSize, 2) +   
       ", SL=" + DoubleToString(stopLoss, symbolDigits) +   
       ", TP=" + DoubleToString(takeProfit, symbolDigits));  
   
   if(!trade.Sell(lotSize, Symbol(), 0, stopLoss, takeProfit, "Gold Volatility Sell"))  
   {  
      Log("ОШИБКА открытия SELL: " + IntegerToString(trade.ResultRetcode()) +   
          ", " + trade.ResultComment());  
      return false;  
   }  
   
   Log("Успешно открыт ордер SELL #" + IntegerToString(trade.ResultOrder()) +   
       " по цене " + DoubleToString(trade.ResultPrice(), symbolDigits));  
   return true;  
}  

//+------------------------------------------------------------------+  
//| Управление открытыми позициями                                   |  
//+------------------------------------------------------------------+  
void ManageOpenPositions()  
{  
   // Ничего не делаем, если трейлинг отключен  
   if(!UseTrailingStop) return;  
   
   // Перебираем открытые позиции  
   for(int i = 0; i < PositionsTotal(); i++)  
   {  
      // Выбираем позицию  
      if(positionInfo.SelectByIndex(i))  
      {  
         // Проверяем, что это наша позиция по текущему инструменту  
         if(positionInfo.Symbol() == Symbol() && positionInfo.Magic() == Magic)  
         {  
            // Получаем тип позиции (LONG/SHORT)  
            ENUM_POSITION_TYPE posType = positionInfo.PositionType();  
            
            // Получаем текущие цены  
            double currentBid = SymbolInfoDouble(Symbol(), SYMBOL_BID);  
            double currentAsk = SymbolInfoDouble(Symbol(), SYMBOL_ASK);  
            
            // Получаем параметры позиции  
            double openPrice = positionInfo.PriceOpen();  
            double stopLoss = positionInfo.StopLoss();  
            double takeProfit = positionInfo.TakeProfit();  
            
            // Для длинных позиций  
            if(posType == POSITION_TYPE_BUY)  
            {  
               // Проверяем, активирован ли трейлинг-стоп  
               if(currentBid - openPrice > TrailingStart * point)  
               {  
                  // Рассчитываем новый стоп-лосс  
                  double newStopLoss = NormalizeDouble(currentBid - TrailingStep * point, symbolDigits);  
                  
                  // Двигаем стоп только если он становится выше  
                  if(newStopLoss > stopLoss)  
                  {  
                     if(trade.PositionModify(positionInfo.Ticket(), newStopLoss, takeProfit))  
                     {  
                        Log("Трейлинг-стоп для BUY #" + IntegerToString(positionInfo.Ticket()) +   
                            " обновлен: " + DoubleToString(newStopLoss, symbolDigits));  
                     }  
                     else  
                     {  
                        Log("Ошибка обновления трейлинг-стопа для BUY #" +   
                            IntegerToString(positionInfo.Ticket()) + ": " +   
                            IntegerToString(trade.ResultRetcode()));  
                     }  
                  }  
               }  
            }  
            // Для коротких позиций  
            else if(posType == POSITION_TYPE_SELL)  
            {  
               // Проверяем, активирован ли трейлинг-стоп  
               if(openPrice - currentAsk > TrailingStart * point)  
               {  
                  // Рассчитываем новый стоп-лосс  
                  double newStopLoss = NormalizeDouble(currentAsk + TrailingStep * point, symbolDigits);  
                  
                  // Двигаем стоп только если он становится ниже  
                  if(newStopLoss < stopLoss || stopLoss == 0)  
                  {  
                     if(trade.PositionModify(positionInfo.Ticket(), newStopLoss, takeProfit))  
                     {  
                        Log("Трейлинг-стоп для SELL #" + IntegerToString(positionInfo.Ticket()) +   
                            " обновлен: " + DoubleToString(newStopLoss, symbolDigits));  
                     }  
                     else  
                     {  
                        Log("Ошибка обновления трейлинг-стопа для SELL #" +   
                            IntegerToString(positionInfo.Ticket()) + ": " +   
                            IntegerToString(trade.ResultRetcode()));  
                     }  
                  }  
               }  
            }  
         }  
      }  
   }  
}  

//+------------------------------------------------------------------+  
//| Функция логирования                                              |  
//+------------------------------------------------------------------+  
void Log(string message)  
{  
   string logMessage = TimeToString(TimeCurrent()) + ": " + message;  
   Print(logMessage);  
   
   if(fileHandle != INVALID_HANDLE)  
   {  
      FileWriteString(fileHandle, logMessage + "\n");  
      FileFlush(fileHandle);  
   }  
}  

//+------------------------------------------------------------------+  
//| Функция вызывается при закрытии позиции                          |  
//+------------------------------------------------------------------+  
void OnTradeTransaction(const MqlTradeTransaction& trans,  
                        const MqlTradeRequest& request,  
                        const MqlTradeResult& result)  
{  
   // Отслеживаем только завершенные операции с позициями  
   if(trans.type != TRADE_TRANSACTION_DEAL_ADD) return;  
   
   // Получаем информацию о сделке  
   ulong dealTicket = trans.deal;  
   if(dealTicket == 0) return;  
   
   HistorySelect(TimeCurrent() - 86400, TimeCurrent()); // Последние 24 часа  
   
   if(HistoryDealSelect(dealTicket))  
   {  
      // Проверяем, что это наша сделка  
      if(HistoryDealGetInteger(dealTicket, DEAL_MAGIC) != Magic) return;  
      
      // Проверяем, что это закрытие позиции  
      ENUM_DEAL_ENTRY dealEntry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(dealTicket, DEAL_ENTRY);  
      if(dealEntry != DEAL_ENTRY_OUT && dealEntry != DEAL_ENTRY_OUT_BY) return;  
      
      // Получаем прибыль  
      double dealProfit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);  
      
      Log("Позиция закрыта с прибылью: " + DoubleToString(dealProfit, 2) + " USD");  
      
      // Обновляем счетчик последовательных убытков  
      if(dealProfit < 0)  
      {  
         consecutiveLosses++;  
         Log("Последовательных убытков: " + IntegerToString(consecutiveLosses));  
      }  
      else  
      {  
         consecutiveLosses = 0;  
         Log("Сброс счетчика убытков после прибыльной сделки");  
      }  
   }  
}
